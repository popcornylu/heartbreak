<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å¿ƒè‡Ÿç—… - å¤šäººå°æˆ°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a5f2a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* ç©å®¶æ‹ç‰Œå€åŸŸ - çµ•å°å®šä½ */
        .slap-zone {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.3);
            transition: background-color 0.3s;
            background: #1a1a1a;
        }

        /* èƒŒæ™¯é¡è‰²é¡åˆ¥ */
        .slap-zone.bg-green { background: #27ae60 !important; }
        .slap-zone.bg-yellow { background: #f39c12 !important; }
        .slap-zone.bg-red { background: #c0392b !important; }
        .slap-zone.bg-black { background: #1a1a1a !important; }

        /* çµæŸç•«é¢ - 2äºº */
        .slap-zone.bg-gradient {
            background: linear-gradient(135deg, #f093fb, #f5576c, #4facfe, #00f2fe) !important;
            background-size: 400% 400%;
            animation: gradientShift 3s ease infinite;
        }

        .slap-zone.bg-gray {
            background: #4a4a4a !important;
            filter: grayscale(100%);
        }

        /* çµæŸç•«é¢ - å¤šäºº */
        .slap-zone.bg-gold {
            background: linear-gradient(135deg, #f5af19, #f12711) !important;
        }

        .slap-zone.bg-silver {
            background: linear-gradient(135deg, #bdc3c7, #2c3e50) !important;
        }

        .slap-zone.bg-bronze {
            background: linear-gradient(135deg, #b8860b, #8b4513) !important;
        }

        /* æ¼¸å±¤å‹•ç•« */
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* çš‡å†  */
        .crown {
            position: absolute;
            font-size: 2.5rem;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 25;
        }

        /* ç´…è‰²æŒ‰éˆ• */
        .slap-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border: 5px solid #922b21;
            box-shadow:
                0 6px 0 #7b241c,
                0 10px 15px rgba(0, 0, 0, 0.5),
                inset 0 -3px 8px rgba(0, 0, 0, 0.3),
                inset 0 3px 8px rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
            margin: 0.5rem auto;
        }

        .slap-button:active {
            transform: translateY(5px);
            box-shadow:
                0 1px 0 #7b241c,
                0 3px 8px rgba(0, 0, 0, 0.5),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }

        /* åé¥‹åœ–ç¤º */
        .feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
        }

        .feedback.show {
            opacity: 1;
        }

        .feedback.correct {
            color: #2ecc71;
            text-shadow: 0 0 30px rgba(46, 204, 113, 0.8);
        }

        .feedback.wrong {
            color: #e74c3c;
            text-shadow: 0 0 30px rgba(231, 76, 60, 0.8);
        }

        .player-info {
            text-align: center;
        }

        .player-name {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .card-count {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 0.3rem;
        }

        /* æ£„ç‰Œå †è¦–è¦ºæ•ˆæœ */
        .discard-pile {
            position: relative;
            width: 80px;
            height: 60px;
            margin: 0.3rem auto;
        }

        .discard-card {
            position: absolute;
            width: 40px;
            height: 56px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: white;
        }

        /* ä¸­é–“ç‰Œå€ */
        .center-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 220px;
            height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #145224;
            border-radius: 15px;
            z-index: 10;
        }

        .call-number {
            font-size: 4rem;
            font-weight: bold;
            color: #f1c40f;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .card-area {
            width: 140px;
            height: 196px;
            position: relative;
            perspective: 1000px;
        }

        .card {
            width: 100%;
            height: 100%;
            position: absolute;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.3s;
        }

        .card.back {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .card.back::before {
            content: "ğŸ‚ ";
            font-size: 5rem;
        }

        .card.front {
            background: white;
        }

        .card.red {
            color: #e74c3c;
        }

        .card.black {
            color: #2c3e50;
        }

        .card.joker {
            color: #9b59b6;
            background: linear-gradient(135deg, #fff 0%, #f0e6ff 100%);
        }

        .deck-count {
            margin-top: 1rem;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.6);
        }

        /* é–‹å§‹ç•«é¢ */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }

        .start-screen h1 {
            font-size: 3rem;
            margin-bottom: 1.5rem;
        }

        .start-screen p {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            color: #bdc3c7;
        }

        .player-selector {
            margin: 1.5rem 0;
            text-align: center;
        }

        .player-selector p {
            font-size: 1.3rem;
            margin-bottom: 1rem;
            color: white;
        }

        .player-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-count-btn {
            padding: 0.8rem 1.5rem;
            font-size: 1.3rem;
            background: #34495e;
            color: white;
            border: 3px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .player-count-btn:hover {
            background: #4a6278;
        }

        .player-count-btn.selected {
            background: #e74c3c;
            border-color: #fff;
        }

        .start-btn {
            margin-top: 1.5rem;
            padding: 1.2rem 3rem;
            font-size: 1.8rem;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }

        .start-btn:active {
            background: #c0392b;
        }

        /* æš«åœæŒ‰éˆ• */
        .pause-btn {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 15;
        }

        .pause-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        /* æš«åœç•«é¢ */
        .pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: white;
        }

        .pause-screen.show {
            display: flex;
        }

        .pause-screen h2 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
        }

        .pause-menu {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .pause-menu button {
            padding: 1rem 2.5rem;
            font-size: 1.3rem;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            min-width: 180px;
        }

        .pause-menu .continue-btn {
            background: #27ae60;
            color: white;
        }

        .pause-menu .restart-btn {
            background: #f39c12;
            color: white;
        }

        .pause-menu .exit-btn {
            background: #e74c3c;
            color: white;
        }

        /* çµæœç•«é¢ */
        .result-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: white;
        }

        .result-screen.show {
            display: flex;
        }

        .result-screen h2 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        /* ç‰ˆæœ¬è™Ÿ */
        .version {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.4);
            z-index: 1000;
        }

        /* è¨Šæ¯æç¤º */
        .message {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            color: #f1c40f;
            text-align: center;
            z-index: 15;
            pointer-events: none;
            white-space: nowrap;
        }

        /* å€’æ•¸è¨ˆæ™‚ */
        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 40px rgba(241, 196, 15, 0.6);
            z-index: 20;
            pointer-events: none;
            display: none;
        }

        .countdown.show {
            display: block;
            animation: countdownPop 0.5s ease-out;
        }

        @keyframes countdownPop {
            0% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* è½‰ç›¤ */
        .spinner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .spinner-overlay.show {
            display: flex;
        }

        .spinner-title {
            font-size: 1.8rem;
            color: #f1c40f;
            margin-bottom: 1.5rem;
            font-weight: bold;
        }

        .spinner-container {
            position: relative;
            width: 260px;
            height: 260px;
        }

        .spinner-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            z-index: 210;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .spinner-wheel {
            width: 260px;
            height: 260px;
            border-radius: 50%;
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99);
            position: relative;
            overflow: hidden;
        }

        .spinner-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: 0 0;
            color: #fff;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            pointer-events: none;
        }

        .spinner-result {
            font-size: 1.5rem;
            color: #e74c3c;
            margin-top: 1.5rem;
            font-weight: bold;
            min-height: 2rem;
        }

        /* ===== éŸ¿æ‡‰å¼è¨­è¨ˆ ===== */

        /* æ‰‹æ©Ÿç›´å‘ (å¯¬åº¦ < 600px) */
        @media screen and (max-width: 600px) {
            .center-area {
                width: 160px;
                height: 240px;
            }

            .call-number {
                font-size: 2.5rem;
            }

            .card-area {
                width: 100px;
                height: 140px;
            }

            .card {
                font-size: 2rem;
                border-radius: 8px;
            }

            .deck-count {
                font-size: 0.9rem;
            }

            .player-name {
                font-size: 1rem;
            }

            .slap-button {
                width: 70px;
                height: 70px;
            }

            .discard-pile {
                width: 50px;
                height: 40px;
            }

            .discard-card {
                width: 25px;
                height: 35px;
                font-size: 0.4rem;
            }

            .card-count {
                font-size: 0.8rem;
            }

            .feedback {
                font-size: 4rem;
            }

            .crown {
                font-size: 1.8rem;
            }

            .pause-btn {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }

            .message {
                font-size: 0.8rem;
            }

            .start-screen h1 {
                font-size: 2rem;
            }

            .start-screen p {
                font-size: 0.9rem;
            }

            .player-count-btn {
                padding: 0.6rem 1rem;
                font-size: 1rem;
            }

            .start-btn {
                padding: 0.8rem 2rem;
                font-size: 1.3rem;
            }

            .pause-screen h2 {
                font-size: 1.8rem;
            }

            .pause-menu button {
                padding: 0.7rem 1.5rem;
                font-size: 1rem;
                min-width: 140px;
            }

            .result-screen h2 {
                font-size: 1.8rem;
            }
        }

        /* ä¸­ç­‰è¢å¹• (600px - 900px) */
        @media screen and (min-width: 601px) and (max-width: 900px) {
            .center-area {
                width: 180px;
                height: 260px;
            }

            .call-number {
                font-size: 3rem;
            }

            .card-area {
                width: 110px;
                height: 154px;
            }

            .slap-button {
                width: 80px;
                height: 80px;
            }

            .feedback {
                font-size: 5rem;
            }
        }
    </style>
</head>
<body>
    <div class="version">v0.8.1</div>

    <!-- é–‹å§‹ç•«é¢ -->
    <div class="start-screen" id="startScreen">
        <h1>â¤ï¸ å¿ƒè‡Ÿç—…</h1>
        <p>éŠæˆ²è¦å‰‡ï¼š</p>
        <p>1. ç³»çµ±è‡ªå‹•å–Šæ•¸ 1â†’2â†’3â†’...â†’13â†’1</p>
        <p>2. ç•¶ç¿»å‡ºçš„ç‰Œ = å–Šçš„æ•¸å­—æ™‚ï¼Œå¿«æ‹ï¼</p>
        <p>3. ğŸƒ Joker å‡ºç¾æ™‚ï¼Œä¸ç®¡å–Šä»€éº¼éƒ½è¦æ‹ï¼</p>
        <p>4. æ‹æ…¢æˆ–æ‹éŒ¯çš„äººæ”¶èµ°ç‰Œå †</p>
        <p>5. 54å¼µç‰Œç™¼å®Œæ™‚ï¼Œæ£„ç‰Œæœ€å°‘è€…ç²å‹ï¼</p>

        <div class="player-selector">
            <p>é¸æ“‡ç©å®¶äººæ•¸ï¼š</p>
            <div class="player-buttons" id="playerButtons">
                <button class="player-count-btn selected" data-count="2">2äºº</button>
                <button class="player-count-btn" data-count="3">3äºº</button>
                <button class="player-count-btn" data-count="4">4äºº</button>
                <button class="player-count-btn" data-count="5">5äºº</button>
                <button class="player-count-btn" data-count="6">6äºº</button>
            </div>
        </div>

        <button class="start-btn" id="startBtn">é–‹å§‹éŠæˆ²</button>
    </div>

    <!-- éŠæˆ²ç•«é¢ -->
    <div class="game-container" id="gameContainer">
        <!-- ä¸­é–“ç‰Œå€ -->
        <div class="center-area" id="centerArea">
            <button class="pause-btn" id="pauseBtn">â¸</button>
            <div class="call-number" id="callNumber">-</div>
            <div class="card-area" id="cardArea"></div>
            <div class="deck-count">ç‰Œå †: <span id="deckCount">0</span></div>
            <div class="message" id="message"></div>
            <div class="countdown" id="countdown"></div>
        </div>

        <!-- ç©å®¶å€åŸŸå°‡å‹•æ…‹ç”Ÿæˆ -->
    </div>

    <!-- æš«åœç•«é¢ -->
    <div class="pause-screen" id="pauseScreen">
        <h2>â¸ éŠæˆ²æš«åœ</h2>
        <div class="pause-menu">
            <button class="continue-btn" id="continueBtn">ç¹¼çºŒéŠæˆ²</button>
            <button class="restart-btn" id="pauseRestartBtn">é‡æ–°é–‹å§‹</button>
            <button class="exit-btn" id="exitBtn">é›¢é–‹éŠæˆ²</button>
        </div>
    </div>

    <!-- è½‰ç›¤ -->
    <div class="spinner-overlay" id="spinnerOverlay">
        <div class="spinner-title">èª°è¦æ”¶ç‰Œï¼Ÿ</div>
        <div class="spinner-container">
            <div class="spinner-pointer">â–¼</div>
            <div class="spinner-wheel" id="spinnerWheel"></div>
        </div>
        <div class="spinner-result" id="spinnerResult"></div>
    </div>

    <!-- çµæœç•«é¢ -->
    <div class="result-screen" id="resultScreen">
        <h2 id="resultText"></h2>
        <button class="start-btn" id="restartBtn">å†ç©ä¸€æ¬¡</button>
    </div>

    <script>
        // éŠæˆ²ç‹€æ…‹
        const state = {
            playerCount: 2,        // ç©å®¶äººæ•¸ (2-6)
            players: [],           // ç©å®¶é™£åˆ— { discard: [], slapRecord: null }
            deck: [],              // ç³»çµ±ç‰Œå †
            centerPile: [],        // ä¸­å¤®ç‰Œå †
            currentNumber: 0,      // ç•¶å‰å–Šçš„æ•¸å­— (1-13)
            currentCard: null,
            isPlaying: false,
            isPaused: false,
            canSlap: false,
            flipTimeout: null,
            countdownTimer: null,
            countdownValue: 0
        };

        // DOM å…ƒç´ 
        const elements = {
            startScreen: document.getElementById('startScreen'),
            startBtn: document.getElementById('startBtn'),
            playerButtons: document.getElementById('playerButtons'),
            gameContainer: document.getElementById('gameContainer'),
            centerArea: document.getElementById('centerArea'),
            callNumber: document.getElementById('callNumber'),
            cardArea: document.getElementById('cardArea'),
            deckCount: document.getElementById('deckCount'),
            message: document.getElementById('message'),
            resultScreen: document.getElementById('resultScreen'),
            resultText: document.getElementById('resultText'),
            restartBtn: document.getElementById('restartBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            pauseScreen: document.getElementById('pauseScreen'),
            continueBtn: document.getElementById('continueBtn'),
            pauseRestartBtn: document.getElementById('pauseRestartBtn'),
            exitBtn: document.getElementById('exitBtn'),
            countdown: document.getElementById('countdown'),
            spinnerOverlay: document.getElementById('spinnerOverlay'),
            spinnerWheel: document.getElementById('spinnerWheel'),
            spinnerResult: document.getElementById('spinnerResult')
        };

        // å‹•æ…‹ç”Ÿæˆçš„ç©å®¶å…ƒç´ 
        let playerElements = [];

        // éŸ³æ•ˆç³»çµ±
        let audioCtx = null;
        function getAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioCtx;
        }

        // ç™¼ç‰ŒéŸ³æ•ˆ
        function playCardSound() {
            const ctx = getAudioContext();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.1);
        }

        // éŒ¯èª¤éŸ³æ•ˆ
        function playErrorSound() {
            const ctx = getAudioContext();
            for (let i = 0; i < 3; i++) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, ctx.currentTime + i * 0.12);
                gain.gain.setValueAtTime(0.2, ctx.currentTime + i * 0.12);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.12 + 0.1);
                osc.start(ctx.currentTime + i * 0.12);
                osc.stop(ctx.currentTime + i * 0.12 + 0.1);
            }
        }

        // æˆåŠŸéŸ³æ•ˆ
        function playSuccessSound() {
            const ctx = getAudioContext();
            const notes = [523, 659, 784, 1047];
            notes.forEach((freq, i) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
                gain.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.15);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.2);
                osc.start(ctx.currentTime + i * 0.15);
                osc.stop(ctx.currentTime + i * 0.15 + 0.2);
            });
        }

        // åˆ¤æ–·æ˜¯å¦è©²æ‹ï¼šJoker æˆ–æ•¸å­—å·® Â±1ï¼ˆå« 1â†”13 å¾ªç’°ï¼‰
        function checkShouldSlap(card, currentNumber) {
            if (!card) return false;
            if (card.isJoker) return true;
            const diff = Math.abs(card.num - currentNumber);
            return diff <= 1 || diff === 12; // diff===12 å³ 1 vs 13
        }

        // æ’²å…‹ç‰ŒèŠ±è‰²
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const suitColors = { 'â™ ': 'black', 'â™¥': 'red', 'â™¦': 'red', 'â™£': 'black' };

        // å»ºç«‹ä¸€å‰¯ç‰Œ (52å¼µ + 2å¼µJoker = 54å¼µ)
        function createDeck() {
            const deck = [];
            for (let suit of suits) {
                for (let num = 1; num <= 13; num++) {
                    deck.push({ suit, num, isJoker: false });
                }
            }
            deck.push({ isJoker: true });
            deck.push({ isJoker: true });
            return shuffle(deck);
        }

        // æ´—ç‰Œ
        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // æ•¸å­—é¡¯ç¤º
        function getCardDisplay(num) {
            const displays = ['', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            return displays[num];
        }

        // è¨ˆç®—ç©å®¶å€åŸŸçš„å¸ƒå±€
        function calculatePlayerLayout(count) {
            const layouts = [];
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            const isPortrait = containerHeight > containerWidth;

            // ä¸­å¤®å€åŸŸå¤§å°
            const centerWidth = isPortrait ? 160 : 220;
            const centerHeight = isPortrait ? 240 : 320;

            // å¯ç”¨å€åŸŸï¼ˆæ‰£é™¤ä¸­å¤®ï¼‰
            const margin = 10;

            if (count === 2) {
                // 2äººï¼šå·¦å³æˆ–ä¸Šä¸‹æ’åˆ—
                if (isPortrait) {
                    // ç›´å‘ï¼šä¸Šä¸‹æ’åˆ—
                    const zoneHeight = (containerHeight - centerHeight) / 2 - margin;
                    layouts.push({
                        top: 0, left: 0, width: containerWidth, height: zoneHeight,
                        rotation: 180
                    });
                    layouts.push({
                        top: containerHeight - zoneHeight, left: 0, width: containerWidth, height: zoneHeight,
                        rotation: 0
                    });
                } else {
                    // æ©«å‘ï¼šå·¦å³æ’åˆ—
                    const zoneWidth = (containerWidth - centerWidth) / 2 - margin;
                    layouts.push({
                        top: 0, left: 0, width: zoneWidth, height: containerHeight,
                        rotation: 180
                    });
                    layouts.push({
                        top: 0, left: containerWidth - zoneWidth, width: zoneWidth, height: containerHeight,
                        rotation: 0
                    });
                }
            } else {
                // 3-6äººï¼šåœ“å½¢æ’åˆ—
                const cx = containerWidth / 2;
                const cy = containerHeight / 2;
                const radiusX = (containerWidth / 2) - 80;
                const radiusY = (containerHeight / 2) - 80;

                // è¨ˆç®—æ¯å€‹ç©å®¶å€åŸŸå¤§å°
                const zoneSize = Math.min(
                    containerWidth / (count <= 4 ? 2.5 : 3),
                    containerHeight / (count <= 4 ? 2.5 : 3),
                    180
                );

                for (let i = 0; i < count; i++) {
                    // å¾åº•éƒ¨é–‹å§‹ï¼Œé †æ™‚é‡æ’åˆ—
                    const angle = (Math.PI / 2) + (2 * Math.PI * i / count);
                    const x = cx + radiusX * Math.cos(angle);
                    const y = cy + radiusY * Math.sin(angle);

                    // æ—‹è½‰è®“æŒ‰éˆ•é¢å‘ä¸­å¿ƒ
                    const rotationDeg = (angle * 180 / Math.PI) - 90;

                    layouts.push({
                        top: y - zoneSize / 2,
                        left: x - zoneSize / 2,
                        width: zoneSize,
                        height: zoneSize,
                        rotation: rotationDeg
                    });
                }
            }

            return layouts;
        }

        // å‰µå»ºç©å®¶å€åŸŸ
        function createPlayerZones(count) {
            // æ¸…é™¤ç¾æœ‰ç©å®¶å€åŸŸ
            playerElements.forEach(el => {
                if (el.zone && el.zone.parentNode) {
                    el.zone.parentNode.removeChild(el.zone);
                }
            });
            playerElements = [];

            const layouts = calculatePlayerLayout(count);

            for (let i = 0; i < count; i++) {
                const layout = layouts[i];

                // å‰µå»ºç©å®¶å€åŸŸ
                const zone = document.createElement('div');
                zone.className = 'slap-zone';
                zone.id = `player${i}Zone`;
                zone.style.top = `${layout.top}px`;
                zone.style.left = `${layout.left}px`;
                zone.style.width = `${layout.width}px`;
                zone.style.height = `${layout.height}px`;
                zone.style.transform = `rotate(${layout.rotation}deg)`;

                // åé¥‹åœ–ç¤º
                const feedback = document.createElement('div');
                feedback.className = 'feedback';
                feedback.id = `player${i}Feedback`;

                // çš‡å† ï¼ˆåˆå§‹éš±è—ï¼‰
                const crown = document.createElement('div');
                crown.className = 'crown hidden';
                crown.id = `player${i}Crown`;
                crown.textContent = 'ğŸ‘‘';

                // ç©å®¶è³‡è¨Š
                const info = document.createElement('div');
                info.className = 'player-info';

                const name = document.createElement('div');
                name.className = 'player-name';
                name.textContent = `ç©å®¶ ${i + 1}`;

                const button = document.createElement('div');
                button.className = 'slap-button';
                button.id = `player${i}Button`;

                const discard = document.createElement('div');
                discard.className = 'discard-pile';
                discard.id = `player${i}Discard`;

                const cardCount = document.createElement('div');
                cardCount.className = 'card-count';
                cardCount.innerHTML = `æ£„ç‰Œ: <span id="player${i}Cards">0</span> å¼µ`;

                info.appendChild(name);
                info.appendChild(button);
                info.appendChild(discard);
                info.appendChild(cardCount);

                zone.appendChild(feedback);
                zone.appendChild(crown);
                zone.appendChild(info);

                elements.gameContainer.appendChild(zone);

                // è¨­å®šäº‹ä»¶ç›£è½
                const playerIndex = i;
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleSlap(playerIndex);
                }, { passive: false });
                button.addEventListener('mousedown', () => handleSlap(playerIndex));

                playerElements.push({
                    zone,
                    feedback,
                    crown,
                    button,
                    discard,
                    cardCount: document.getElementById(`player${i}Cards`)
                });
            }
        }

        // è¦–çª—å¤§å°æ”¹è®Šæ™‚é‡æ–°è¨ˆç®—å¸ƒå±€
        function updateLayout() {
            if (!state.isPlaying) return;

            const layouts = calculatePlayerLayout(state.playerCount);

            playerElements.forEach((el, i) => {
                if (layouts[i]) {
                    const layout = layouts[i];
                    el.zone.style.top = `${layout.top}px`;
                    el.zone.style.left = `${layout.left}px`;
                    el.zone.style.width = `${layout.width}px`;
                    el.zone.style.height = `${layout.height}px`;
                    el.zone.style.transform = `rotate(${layout.rotation}deg)`;
                }
            });
        }

        window.addEventListener('resize', updateLayout);

        // é¡¯ç¤ºå¡ç‰Œ
        function displayCard(card) {
            const cardEl = document.createElement('div');

            if (card.isJoker) {
                cardEl.className = 'card front joker';
                cardEl.innerHTML = 'ğŸƒ<br>JOKER';
            } else {
                const display = getCardDisplay(card.num);
                const color = suitColors[card.suit];
                cardEl.className = `card front ${color}`;
                cardEl.innerHTML = `${card.suit}<br>${display}`;
            }

            const rotation = (Math.random() - 0.5) * 30;
            const offsetX = (Math.random() - 0.5) * 20;
            const offsetY = (Math.random() - 0.5) * 20;
            const pileIndex = elements.cardArea.children.length;

            cardEl.style.transform = `translate(${offsetX}px, ${offsetY}px) rotate(${rotation}deg)`;
            cardEl.style.zIndex = pileIndex;

            elements.cardArea.appendChild(cardEl);
        }

        // æ¸…ç©ºç‰Œå †è¦–è¦º
        function clearPileVisual() {
            elements.cardArea.innerHTML = '';
        }

        // é¡¯ç¤ºç‰ŒèƒŒ
        function displayCardBack() {
            clearPileVisual();
        }

        // é¡¯ç¤ºè¨Šæ¯
        function showMessage(text, duration = 1500) {
            elements.message.textContent = text;
            setTimeout(() => {
                elements.message.textContent = '';
            }, duration);
        }

        // é¡¯ç¤ºåé¥‹
        function showFeedback(playerIndex, isCorrect) {
            const el = playerElements[playerIndex];
            if (el) {
                el.feedback.textContent = isCorrect ? 'â­•' : 'âŒ';
                el.feedback.className = `feedback show ${isCorrect ? 'correct' : 'wrong'}`;
            }
        }

        // è¨­å®šç©å®¶èƒŒæ™¯é¡è‰²
        function setPlayerBackground(playerIndex, colorClass) {
            const el = playerElements[playerIndex];
            if (el) {
                // ç§»é™¤æ‰€æœ‰èƒŒæ™¯é¡åˆ¥
                el.zone.classList.remove('bg-green', 'bg-yellow', 'bg-red', 'bg-black', 'bg-gradient', 'bg-gray', 'bg-gold', 'bg-silver', 'bg-bronze');
                el.zone.style.filter = '';

                if (colorClass) {
                    el.zone.classList.add(`bg-${colorClass}`);
                }
            }
        }

        // é¡¯ç¤ºçš‡å† 
        function showCrown(playerIndex) {
            const el = playerElements[playerIndex];
            if (el) {
                el.crown.classList.remove('hidden');
            }
        }

        // æ¸…é™¤æ‰€æœ‰åé¥‹å’ŒèƒŒæ™¯
        function clearAllFeedback() {
            playerElements.forEach(el => {
                el.feedback.className = 'feedback';
                el.zone.classList.remove('bg-green', 'bg-yellow', 'bg-red', 'bg-black', 'bg-gradient', 'bg-gray', 'bg-gold', 'bg-silver', 'bg-bronze');
                el.zone.style.filter = '';
                el.crown.classList.add('hidden');
            });
        }

        // æ›´æ–°æ£„ç‰Œå †è¦–è¦º
        function updateDiscardVisual(discardElement, cards) {
            const currentCount = discardElement.children.length;
            const maxVisible = 10;

            for (let i = currentCount; i < cards.length && i < maxVisible; i++) {
                const card = document.createElement('div');
                card.className = 'discard-card';
                const rotation = (Math.random() - 0.5) * 40;
                const offsetX = (Math.random() - 0.5) * 40;
                const offsetY = (Math.random() - 0.5) * 20;
                card.style.left = `${20 + offsetX}px`;
                card.style.top = `${5 + offsetY}px`;
                card.style.transform = `rotate(${rotation}deg)`;
                card.style.zIndex = i;
                card.textContent = 'ğŸ‚ ';
                discardElement.appendChild(card);
            }
        }

        // æ›´æ–°ç•«é¢
        function updateUI() {
            playerElements.forEach((el, i) => {
                if (state.players[i]) {
                    el.cardCount.textContent = state.players[i].discard.length;
                }
            });
            elements.deckCount.textContent = state.deck.length;
        }

        // åˆå§‹åŒ–ç©å®¶ç‹€æ…‹
        function initPlayers(count) {
            state.players = [];
            for (let i = 0; i < count; i++) {
                state.players.push({
                    discard: [],
                    slapRecord: null
                });
            }
        }

        // é–‹å§‹éŠæˆ²
        function startGame() {
            elements.startScreen.classList.add('hidden');

            // åˆå§‹åŒ–ç©å®¶
            initPlayers(state.playerCount);
            createPlayerZones(state.playerCount);

            // å»ºç«‹ä¸¦æ´—ç‰Œ
            state.deck = createDeck();
            state.centerPile = [];
            state.currentNumber = 0;
            state.isPlaying = true;
            state.isPaused = false;
            state.canSlap = false;
            clearCountdown();
            elements.spinnerOverlay.classList.remove('show');

            // æ¸…ç©ºæ£„ç‰Œå †è¦–è¦º
            playerElements.forEach(el => {
                el.discard.innerHTML = '';
            });

            updateUI();
            displayCardBack();
            elements.callNumber.textContent = '-';

            setTimeout(flipCard, 1500);
        }

        // ç¿»ç‰Œ
        function flipCard() {
            if (!state.isPlaying) return;

            if (state.deck.length === 0) {
                endGame();
                return;
            }

            // é‡ç½®æ‹ç‰Œç´€éŒ„å’Œåé¥‹
            state.players.forEach(p => p.slapRecord = null);
            state.canSlap = false;
            clearAllFeedback();

            // æ›´æ–°å–Šçš„æ•¸å­—
            state.currentNumber = (state.currentNumber % 13) + 1;
            elements.callNumber.textContent = getCardDisplay(state.currentNumber);

            // å¾ç‰Œå †æŠ½ä¸€å¼µç‰Œ
            const card = state.deck.pop();
            state.currentCard = card;
            state.centerPile.push(card);

            displayCard(card);
            playCardSound();
            updateUI();

            state.canSlap = true;

            const shouldSlap = checkShouldSlap(card, state.currentNumber);

            if (shouldSlap) {
                // æ‰€æœ‰æ¨¡å¼ï¼šé–‹å§‹ 3 ç§’å€’æ•¸
                startCountdown(3);
            } else {
                state.flipTimeout = setTimeout(() => {
                    if (state.isPlaying && !state.isPaused) {
                        flipCard();
                    }
                }, 1200);
            }
        }

        // è™•ç†æ‹ç‰Œ
        function handleSlap(playerIndex) {
            if (!state.isPlaying || !state.canSlap || state.isPaused) return;
            if (playerIndex < 0 || playerIndex >= state.players.length) return;

            const now = performance.now();
            const shouldSlap = checkShouldSlap(state.currentCard, state.currentNumber);

            // æª¢æŸ¥æ˜¯å¦å·²ç¶“æŒ‰é
            if (state.players[playerIndex].slapRecord !== null) return;

            // è¨˜éŒ„æ‹ç‰Œ
            state.players[playerIndex].slapRecord = { time: now, correct: shouldSlap };

            // ç«‹å³é¡¯ç¤ºåé¥‹
            showFeedback(playerIndex, shouldSlap);

            // è¨ˆç®—å·²æ‹äººæ•¸
            const slappedCount = state.players.filter(p => p.slapRecord !== null).length;
            const totalPlayers = state.players.length;

            if (shouldSlap) {
                // è©²æ‹çš„ç‰Œï¼šç­‰åˆ° N-1 äººæ‹äº†ï¼Œæœ€å¾Œä¸€å€‹æ²’æ‹çš„äººå°±æ˜¯è¼¸å®¶
                if (slappedCount >= totalPlayers - 1) {
                    clearTimeout(state.flipTimeout);
                    clearCountdown();
                    state.canSlap = false;
                    judgeSlap();
                }
                // é‚„æ²’åˆ° N-1 äººï¼Œç¹¼çºŒç­‰å¾…
            } else {
                // ä¸è©²æ‹çš„ç‰Œï¼šæœ‰äººæ‹éŒ¯äº†ï¼ŒçŸ­æš«å»¶é²å¾Œåˆ¤æ–·
                clearTimeout(state.flipTimeout);
                state.flipTimeout = setTimeout(() => {
                    if (state.canSlap) {
                        state.canSlap = false;
                        judgeSlap();
                    }
                }, 500);
            }
        }

        // å€’æ•¸è¨ˆæ™‚ï¼ˆ3+ äºº shouldSlap æ™‚ä½¿ç”¨ï¼‰
        function startCountdown(seconds) {
            state.countdownValue = seconds;
            const countdownEl = elements.countdown;
            countdownEl.textContent = seconds;
            countdownEl.className = 'countdown show';

            state.countdownTimer = setInterval(() => {
                if (state.isPaused) return;
                state.countdownValue--;
                if (state.countdownValue > 0) {
                    countdownEl.textContent = state.countdownValue;
                    // é‡æ–°è§¸ç™¼å‹•ç•«
                    countdownEl.className = 'countdown';
                    void countdownEl.offsetWidth; // force reflow
                    countdownEl.className = 'countdown show';
                } else {
                    // å€’æ•¸çµæŸ
                    clearInterval(state.countdownTimer);
                    state.countdownTimer = null;
                    countdownEl.className = 'countdown';
                    state.canSlap = false;
                    onCountdownEnd();
                }
            }, 1000);
        }

        function clearCountdown() {
            if (state.countdownTimer) {
                clearInterval(state.countdownTimer);
                state.countdownTimer = null;
            }
            elements.countdown.className = 'countdown';
            state.countdownValue = 0;
        }

        function onCountdownEnd() {
            const notSlapped = state.players
                .map((p, i) => ({ index: i, slapped: p.slapRecord !== null }))
                .filter(p => !p.slapped);
            const slappedCount = state.players.length - notSlapped.length;

            if (slappedCount === 0) {
                // æ²’æœ‰äººæ‹ â†’ ç¹¼çºŒå‡ºç‰Œ
                state.flipTimeout = setTimeout(() => {
                    if (state.isPaused) return;
                    clearAllFeedback();
                    displayCardBack();
                    state.flipTimeout = setTimeout(() => {
                        if (state.isPlaying && !state.isPaused) flipCard();
                    }, 1000);
                }, 500);
            } else if (notSlapped.length <= 1) {
                // 0 æˆ– 1 äººæ²’æ‹ â†’ ç›´æ¥åˆ¤å®š
                judgeSlap();
            } else {
                // è¶…é 1 äººæ²’æ‹ï¼ˆä½†æœ‰äººæ‹äº†ï¼‰â†’ è½‰ç›¤
                showSpinner(notSlapped.map(p => p.index));
            }
        }

        // è½‰ç›¤åŠŸèƒ½
        function showSpinner(candidates) {
            const overlay = elements.spinnerOverlay;
            const wheel = elements.spinnerWheel;
            const result = elements.spinnerResult;

            // è‰²å¡Šé¡è‰²
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'];
            const n = candidates.length;
            const sliceAngle = 360 / n;

            // ç”¨ conic-gradient ç•«è‰²å¡Š
            let gradient = '';
            for (let i = 0; i < n; i++) {
                const startAngle = i * sliceAngle;
                const endAngle = (i + 1) * sliceAngle;
                const color = colors[i % colors.length];
                gradient += `${color} ${startAngle}deg ${endAngle}deg`;
                if (i < n - 1) gradient += ', ';
            }
            wheel.style.background = `conic-gradient(${gradient})`;

            // æ¸…é™¤èˆŠæ¨™ç±¤
            wheel.innerHTML = '';

            // æ·»åŠ ç©å®¶æ¨™ç±¤
            for (let i = 0; i < n; i++) {
                const label = document.createElement('div');
                label.className = 'spinner-label';
                label.textContent = `P${candidates[i] + 1}`;
                // ç½®æ–¼è‰²å¡Šä¸­é–“
                const midAngle = (i * sliceAngle + sliceAngle / 2) - 90; // -90 å› ç‚º conic å¾ä¸Šæ–¹é–‹å§‹
                const rad = midAngle * Math.PI / 180;
                const labelRadius = 90;
                const lx = labelRadius * Math.cos(rad);
                const ly = labelRadius * Math.sin(rad);
                label.style.transform = `translate(${lx - 15}px, ${ly - 10}px)`;
                wheel.appendChild(label);
            }

            // é‡ç½®æ—‹è½‰
            wheel.style.transition = 'none';
            wheel.style.transform = 'rotate(0deg)';
            void wheel.offsetWidth; // force reflow

            result.textContent = '';
            overlay.classList.add('show');

            // éš¨æ©Ÿæ±ºå®šæœ€çµ‚åœæ­¢ä½ç½®ï¼ˆé¸ä¸­çš„å€™é¸äººç´¢å¼•ï¼‰
            const winnerIdx = Math.floor(Math.random() * n);
            // è¨ˆç®—åœæ­¢è§’åº¦ï¼šæŒ‡é‡åœ¨é ‚éƒ¨ï¼ˆ0åº¦ï¼‰ï¼Œéœ€è¦è®“ winnerIdx çš„è‰²å¡Šä¸­å¿ƒå°æº–é ‚éƒ¨
            // conic-gradient å¾é ‚éƒ¨é †æ™‚é‡ç•«ï¼Œæ‰€ä»¥è‰²å¡Š i çš„ä¸­å¿ƒåœ¨ (i+0.5)*sliceAngle åº¦
            // æ—‹è½‰å¾Œï¼ŒæŒ‡é‡æŒ‡å‘çš„è§’åº¦ = totalRotation % 360
            // æˆ‘å€‘éœ€è¦ totalRotation % 360 = winnerIdx è‰²å¡Šä¸­å¿ƒ
            const targetSliceCenter = 360 - (winnerIdx + 0.5) * sliceAngle;
            const extraSpins = 5 + Math.floor(Math.random() * 3); // 5-7 åœˆ
            const totalRotation = extraSpins * 360 + targetSliceCenter;

            // é–‹å§‹æ—‹è½‰
            setTimeout(() => {
                wheel.style.transition = 'transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99)';
                wheel.style.transform = `rotate(${totalRotation}deg)`;
            }, 100);

            // æ—‹è½‰çµæŸå¾Œ
            setTimeout(() => {
                const loserIndex = candidates[winnerIdx];
                const pileCount = state.centerPile.length;

                result.textContent = `ç©å®¶${loserIndex + 1} æ”¶ ${pileCount} å¼µç‰Œ`;

                // è¨­å®šèƒŒæ™¯ï¼šæœ‰æ‹çš„äººç¬¬ä¸€å€‹ç¶ è‰²ã€å…¶ä»–é»ƒè‰²ï¼Œè¼¸å®¶ç´…è‰²
                const slaps = state.players
                    .map((p, i) => ({ index: i, record: p.slapRecord }))
                    .filter(p => p.record !== null)
                    .sort((a, b) => a.record.time - b.record.time);

                slaps.forEach((slap, rank) => {
                    if (rank === 0) {
                        setPlayerBackground(slap.index, 'green');
                    } else {
                        setPlayerBackground(slap.index, 'yellow');
                    }
                    showFeedback(slap.index, true);
                });

                // æ²’æ‹çš„äººæ¨™ç´…/é»ƒ
                candidates.forEach(ci => {
                    if (ci === loserIndex) {
                        setPlayerBackground(ci, 'red');
                    } else {
                        setPlayerBackground(ci, 'yellow');
                    }
                    showFeedback(ci, false);
                });

                // è¼¸å®¶æ”¶ç‰Œ
                state.players[loserIndex].discard.push(...state.centerPile);
                updateDiscardVisual(playerElements[loserIndex].discard, state.players[loserIndex].discard);

                state.centerPile = [];
                state.currentNumber = 0;
                updateUI();

                playErrorSound();

                // 2ç§’å¾Œé—œé–‰è½‰ç›¤ï¼Œç¹¼çºŒéŠæˆ²
                setTimeout(() => {
                    overlay.classList.remove('show');

                    if (state.deck.length === 0) {
                        state.flipTimeout = setTimeout(() => {
                            if (!state.isPaused) endGame();
                        }, 1500);
                    } else {
                        state.flipTimeout = setTimeout(() => {
                            if (state.isPaused) return;
                            clearAllFeedback();
                            displayCardBack();
                            state.flipTimeout = setTimeout(() => {
                                if (state.isPlaying && !state.isPaused) flipCard();
                            }, 1000);
                        }, 1500);
                    }
                }, 2000);
            }, 4200); // ç•¥å¤šæ–¼ 4s transition æ™‚é–“
        }

        // åˆ¤æ–·æ‹ç‰Œçµæœ
        function judgeSlap() {
            const pileCount = state.centerPile.length;
            const shouldSlap = checkShouldSlap(state.currentCard, state.currentNumber);

            // æ”¶é›†æ‰€æœ‰æ‹ç‰Œçš„äºº
            const slaps = state.players
                .map((p, i) => ({ index: i, record: p.slapRecord }))
                .filter(p => p.record !== null)
                .sort((a, b) => a.record.time - b.record.time);

            // æ²’æ‹çš„äºº
            const notSlapped = state.players
                .map((p, i) => ({ index: i, slapped: p.slapRecord !== null }))
                .filter(p => !p.slapped);

            if (slaps.length === 0) {
                // éƒ½æ²’æ‹
                state.flipTimeout = setTimeout(() => {
                    if (state.isPlaying && !state.isPaused) flipCard();
                }, 1000);
                return;
            }

            // åˆ†é¡
            const correctSlaps = slaps.filter(s => s.record.correct);
            const wrongSlaps = slaps.filter(s => !s.record.correct);

            let loser = null;

            if (shouldSlap) {
                // è©²æ‹çš„ç‰Œ
                if (notSlapped.length > 0) {
                    // æœ‰äººæ²’æ‹ â†’ æ²’æ‹çš„äººè¼¸
                    loser = notSlapped[0].index;

                    // æŒ‰ç…§é †åºæ¨™è¨˜é¡è‰²ï¼šç¬¬ä¸€å€‹ç¶ è‰²ï¼Œä¸­é–“é»ƒè‰²
                    correctSlaps.forEach((slap, rank) => {
                        if (rank === 0) {
                            setPlayerBackground(slap.index, 'green');
                        } else {
                            setPlayerBackground(slap.index, 'yellow');
                        }
                    });

                    // æ²’æ‹çš„äººæ¨™ç´…ï¼ˆè¼¸å®¶ï¼‰
                    notSlapped.forEach(p => {
                        setPlayerBackground(p.index, 'red');
                    });

                    playSuccessSound();
                    setTimeout(playErrorSound, 300);
                } else if (correctSlaps.length > 0) {
                    // æ‰€æœ‰äººéƒ½æ‹äº†ï¼Œæœ‰äººæŒ‰å°
                    // æœ€æ…¢æŒ‰å°çš„äººè¼¸ï¼ˆæ”¶ç‰Œï¼‰
                    const slowestCorrect = correctSlaps[correctSlaps.length - 1];
                    loser = slowestCorrect.index;

                    // è¨­å®šèƒŒæ™¯é¡è‰²ï¼šç¬¬ä¸€å€‹ç¶ è‰²ï¼Œä¸­é–“é»ƒè‰²ï¼Œæœ€å¾Œç´…è‰²
                    correctSlaps.forEach((slap, rank) => {
                        if (rank === 0) {
                            // æœ€å¿«æŒ‰å° â†’ ç¶ è‰²
                            setPlayerBackground(slap.index, 'green');
                        } else if (rank === correctSlaps.length - 1) {
                            // æœ€æ…¢æŒ‰å° â†’ ç´…è‰²ï¼ˆè¼¸å®¶ï¼‰
                            setPlayerBackground(slap.index, 'red');
                        } else {
                            // ä¸­é–“ â†’ é»ƒè‰²
                            setPlayerBackground(slap.index, 'yellow');
                        }
                    });

                    if (correctSlaps.length > 1) {
                        playSuccessSound();
                        setTimeout(playErrorSound, 300);
                    } else {
                        // åªæœ‰ä¸€å€‹äººæŒ‰å°ï¼Œé‚£å€‹äººå°±æ˜¯è¼¸å®¶ï¼ˆç´…è‰²ï¼‰
                        setPlayerBackground(correctSlaps[0].index, 'red');
                        playErrorSound();
                    }
                }
            } else {
                // ä¸è©²æ‹çš„ç‰Œï¼Œæœ‰äººæ‹éŒ¯äº†
                // æœ€å¿«æŒ‰éŒ¯çš„äººè¼¸
                const fastestWrong = wrongSlaps[0];
                loser = fastestWrong.index;

                wrongSlaps.forEach((slap, rank) => {
                    if (rank === 0) {
                        // æœ€å¿«æŒ‰éŒ¯ â†’ ç´…è‰²
                        setPlayerBackground(slap.index, 'red');
                    } else {
                        // éæœ€å¿«æŒ‰éŒ¯ â†’ é»ƒè‰²
                        setPlayerBackground(slap.index, 'yellow');
                    }
                });

                playErrorSound();
            }

            // è¼¸å®¶æ”¶ç‰Œ
            if (loser !== null && state.players[loser]) {
                state.players[loser].discard.push(...state.centerPile);
                showMessage(`ç©å®¶${loser + 1} æ”¶ ${pileCount} å¼µç‰Œ`);
                updateDiscardVisual(playerElements[loser].discard, state.players[loser].discard);
            }

            state.centerPile = [];
            state.currentNumber = 0; // é‡æ–°å¾1é–‹å§‹æ•¸
            updateUI();

            if (state.deck.length === 0) {
                state.flipTimeout = setTimeout(() => {
                    if (!state.isPaused) endGame();
                }, 1500);
            } else {
                state.flipTimeout = setTimeout(() => {
                    if (state.isPaused) return;
                    clearAllFeedback();
                    displayCardBack();
                    state.flipTimeout = setTimeout(() => {
                        if (state.isPlaying && !state.isPaused) flipCard();
                    }, 1000);
                }, 1500);
            }
        }

        // çµæŸéŠæˆ²
        function endGame() {
            state.isPlaying = false;
            clearTimeout(state.flipTimeout);
            clearCountdown();

            // æ ¹æ“šæ£„ç‰Œæ•¸é‡æ’å
            const rankings = state.players
                .map((p, i) => ({ index: i, count: p.discard.length }))
                .sort((a, b) => a.count - b.count);

            let resultText = '';

            if (state.playerCount === 2) {
                // 2äººæ¨¡å¼
                if (rankings[0].count === rankings[1].count) {
                    // å¹³æ‰‹
                    resultText = `ğŸ¤ å¹³æ‰‹ï¼\n(é›™æ–¹éƒ½æ˜¯ ${rankings[0].count} å¼µæ£„ç‰Œ)`;
                } else {
                    const winner = rankings[0];
                    const loser = rankings[1];

                    // è´å®¶ï¼šå½©è‰²æ¼¸å±¤èƒŒæ™¯
                    setPlayerBackground(winner.index, 'gradient');
                    // è¼¸å®¶ï¼šç°è‰² + grayscale filter
                    setPlayerBackground(loser.index, 'gray');

                    resultText = `ğŸ‰ ç©å®¶ ${winner.index + 1} ç²å‹ï¼\n(${winner.count} vs ${loser.count} å¼µæ£„ç‰Œ)`;
                }
            } else {
                // 3-6äººæ¨¡å¼
                rankings.forEach((player, rank) => {
                    switch(rank) {
                        case 0: // ç¬¬1å
                            setPlayerBackground(player.index, 'gold');
                            showCrown(player.index);
                            break;
                        case 1: // ç¬¬2å
                            setPlayerBackground(player.index, 'silver');
                            break;
                        case 2: // ç¬¬3å
                            setPlayerBackground(player.index, 'bronze');
                            break;
                        default: // å…¶ä»–
                            setPlayerBackground(player.index, 'black');
                    }
                });

                const winner = rankings[0];
                resultText = `ğŸ‘‘ ç©å®¶ ${winner.index + 1} ç²å‹ï¼\nğŸ¥‡ ç¬¬1å: ç©å®¶${winner.index + 1} (${winner.count}å¼µ)`;

                if (rankings.length > 1) {
                    resultText += `\nğŸ¥ˆ ç¬¬2å: ç©å®¶${rankings[1].index + 1} (${rankings[1].count}å¼µ)`;
                }
                if (rankings.length > 2) {
                    resultText += `\nğŸ¥‰ ç¬¬3å: ç©å®¶${rankings[2].index + 1} (${rankings[2].count}å¼µ)`;
                }
            }

            elements.resultText.innerHTML = resultText.replace(/\n/g, '<br>');
            elements.resultScreen.classList.add('show');
        }

        // æš«åœéŠæˆ²
        function pauseGame() {
            if (!state.isPlaying || state.isPaused) return;
            state.isPaused = true;
            clearTimeout(state.flipTimeout);
            // æš«åœæ™‚ä¿ç•™ countdownValue ä½†æ¸…é™¤ timer
            if (state.countdownTimer) {
                clearInterval(state.countdownTimer);
                state.countdownTimer = null;
            }
            elements.countdown.className = 'countdown';
            elements.pauseScreen.classList.add('show');
        }

        // ç¹¼çºŒéŠæˆ²
        function resumeGame() {
            if (!state.isPaused) return;
            state.isPaused = false;
            elements.pauseScreen.classList.remove('show');
            if (state.canSlap && state.countdownValue > 0) {
                // æ¢å¾©å€’æ•¸
                startCountdown(state.countdownValue);
            } else if (!state.canSlap) {
                setTimeout(flipCard, 500);
            }
        }

        // é›¢é–‹éŠæˆ²
        function exitGame() {
            state.isPlaying = false;
            state.isPaused = false;
            clearTimeout(state.flipTimeout);
            clearCountdown();
            elements.spinnerOverlay.classList.remove('show');
            elements.pauseScreen.classList.remove('show');
            elements.startScreen.classList.remove('hidden');
        }

        // ç©å®¶äººæ•¸é¸æ“‡
        function setupPlayerSelector() {
            const buttons = elements.playerButtons.querySelectorAll('.player-count-btn');
            buttons.forEach(btn => {
                const handler = (e) => {
                    e.preventDefault();
                    buttons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    state.playerCount = parseInt(btn.dataset.count);
                };
                btn.addEventListener('click', handler);
                btn.addEventListener('touchend', handler);
            });
        }

        // è§¸æ§äº‹ä»¶è™•ç†
        function setupTouchEvents() {
            document.addEventListener('touchstart', (e) => {
                e.preventDefault();
            }, { passive: false });
        }

        // æŒ‰éˆ•äº‹ä»¶
        elements.startBtn.addEventListener('click', startGame);
        elements.startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            startGame();
        });
        elements.restartBtn.addEventListener('click', () => {
            elements.resultScreen.classList.remove('show');
            clearAllFeedback();
            startGame();
        });
        elements.restartBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            elements.resultScreen.classList.remove('show');
            clearAllFeedback();
            startGame();
        });

        elements.pauseBtn.addEventListener('click', pauseGame);
        elements.pauseBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            pauseGame();
        });

        elements.continueBtn.addEventListener('click', resumeGame);
        elements.continueBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            resumeGame();
        });

        elements.pauseRestartBtn.addEventListener('click', () => {
            elements.pauseScreen.classList.remove('show');
            state.isPaused = false;
            clearAllFeedback();
            startGame();
        });
        elements.pauseRestartBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            elements.pauseScreen.classList.remove('show');
            state.isPaused = false;
            clearAllFeedback();
            startGame();
        });

        elements.exitBtn.addEventListener('click', exitGame);
        elements.exitBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            exitGame();
        });

        // åˆå§‹åŒ–
        setupTouchEvents();
        setupPlayerSelector();

        // é˜²æ­¢ç¸®æ”¾
        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('gesturechange', (e) => e.preventDefault());
    </script>
</body>
</html>
